\section{Introduction}
\label{sec:intro}

How best to store and manage secrets -- the bits of sensitive data
necessary to bootstrap or ensure the security of computing systems and
services -- has always been a non-trivial problem. As we continue to
move toward computing and storage platforms controlled by third
parties, and embrace modern trends toward ephemeral infrastructure,
the secret-storage problem only becomes more prevalent and critical to
solve.

Tutamen\footnote{Latin for ``A means of protection or defense.''} is
our attempt to solve the secret-storage problem in a manner that
allows the user to adhere to a range of security and privacy
requirements without sacrificing functionality in the process. Tutamen
is a next-generation secret-storage platform. It builds on our
previous secret-storage efforts~\cite{custos-trios} as well as various
secret-storage systems available today~\cite{vault, confidant,
  keywhiz}.

In this paper, we present the design, implementation, and evaluation
of a secret-storage system with support for several novel features. We
also provide several practical demonstrations of how our
secret-storage system can be integrated with real world applications
to offer desirable features in a secure and easy-to-use
manner. Tutamen's primary selling points include:
\begin{packed_item}
\item A modular authentication system designed to support contextual,
  multi-factor, and alternate-band (e.g., SMS text messages)
  authentication mechanisms.
\item The ability to operate atop minimally trusted infrastructure by
  leveraging multiple storage and access control providers to achieve
  redundancy and mitigate trust.
\item The ability to share and manage secrets beyond the boundaries
  of a single administrative domain.
\end{packed_item}

\subsection{The Need for Secret-Storage}

Computing systems invade every facet of our lives, from the fitness
trackers on our wrists, to our ``smart'' home appliances, to the
server infrastructure required to support the range of websites and
services we interact with every day. With this explosion of computing
systems has come an equally large explosion in the amount of data
stored by and about us. While some of this data is designed to be
public (e.g., the entries on Wikipedia), much of it is not, requiring
the enforcement of various privacy and security guarantees with
respect to its handling and storage. The basis of providing such
guarantees relies on our ability to store and selectively share
secrets ranging from the keys used to encrypt our data to the
passwords used to protect our online accounts. How best to store and
manage these secrets is thus a critical question, the answer to which
forms the foundation for all of computing's higher level security and
privacy guarantees.

Beyond the need to bootstrap a variety of security guarantees, there
are several other factors driving the need for robust secret-storage
solutions. On the systems administration front, the trend toward
ephemeral infrastructure capable of rapidly scaling up or down is
driving the adoption of configuration management systems such as
Puppet~\cite{puppet} or Chef~\cite{chef}. Such systems, however, do
not tend to have suitable mechanisms for enforcing the security and
privacy requirements inherent to storing secrets. Nonetheless,
configuration data often contains a variety of secrets such as SSH
keys, TLS/SSL keys, and the tokens or credentials necessary to
authenticate to external APIs and services.

Similarly, on the end user front, the need for suitable secret-storage
systems is being driven by a rapid expansion of the number of sites
and services to which users must authenticate themselves and the
growing expanse of digital data and computing devices users wish to
protect. Indeed, the popularity of password management systems such as
LastPass~\cite{lastpass} or 1Password~\cite{onepassword} and the
increasing trend toward ``on-by-default'' device-encryption
demonstrate the importance of secret-storage and the applications it
enables to end users.

\subsection{Motivating Examples}

As a motivating example, consider the popular Dropbox cloud file
locker service~\cite{dropbox}, through which users may upload
arbitrary files in order to sync them between multiple devices and to
share them with other users. While Dropbox provides encryption for
data in transit between the Dropbox servers and a client
machine~\cite{dropbox-security}, Dropbox also holds a copy of the
associated encryption keys, enabling them to decrypt a user's files
whenever they desire (or when they are breached or compelled to
provide such data). To overcome this deficiency, a Dropbox user could
employ some form of ``client-side'' encryption whereby they encrypt
all data locally and ensure Dropbox itself never has access to the
their files. Unfortunately, such a solution begets a number of
additional challenges, namely:

\begin{packed_enum}
\item It breaks Dropbox's sharing use case. While users could still
  share encrypted versions of their files with other users via
  Dropbox, they would also have to exchange the associated encryption
  key out-of-band in order to decrypt and read or update any shared
  file. Such out-of-band key exchange is burdensome and calls into
  question the utility of client-side encrypting a service such as
  Dropbox in the first place.
\item It complicates Dropbox's syncing use case. Whereas before a
  Dropbox user could bootstrap a new Dropbox client device simply by
  signing into their Dropbox account, users must now both sign into
  their Dropbox account and manually transfer a copy of their
  encryption key to the new device to enable the required encryption
  and decryption operations. Again, this manual key management process
  is burdensome and prone to error.
\end{packed_enum}

These challenges are not unique to Dropbox. There are many modern
examples of security and privacy enhancing technologies being hindered
by the lack of good solutions in the secret storage space. For
example, full disk encryption systems traditionally require a human to
manually enter secret in order to boot the system -- a requirement
that makes full disk encryption largely unusable in deployments where
no human can reasonably be expected to be present at boot time
(e.g. in a large datacenter deployment or atop third party cloud
infrastructure). Mobile computing devices are prone to loss and theft,
but are routinely used to store large amounts of user data -- much of
which could be reasonably classified as ``secret'' (e.g. social
security numbers and credit card details) and which should not be
stored unprotected on theft-prone devices. Password manager have grown
in popularity as a means to help users manage the burden of
remembering the secrets (e.g. passwords) necessary to access the
services they use each day, but such services generally require
placing a high degree of trust in a single third party provider.

\subsection{The Ideal Secret-Storage System}

To address these challenges and overcome existing deficiencies, users
require a mechanism for securely storing, managing, and exchanging a
wide range of secrets. Unlike standard configuration management
systems, or even specific secret-storage systems such as password
managers, general purpose secret-storage presents a number of unique
requirements, including the following capabilities:

\begin{packed_item}
\item Store arbitrary secret data.
\item Secure the manner in which secrets are stored.
\item Enforce fine-grained access control requirements.
\item Support a range of authentication sources/methods.
\item Provide audit logs tracking secret-access history.
\end{packed_item}

In response to these needs, a number of general purpose secret-storage
systems have recently been developed by industry, including
HashiCorp's Vault~\cite{vault}, Lyft's Confidant~\cite{confidant}, and
Square's Keywhiz~\cite{keywhiz}. These systems exist to fulfill some
or all of the requirements listed above. We believe, however, that
such systems are hindered by several key limitations. First, they
generally require at least one fully trusted server as the basis of
their security model, making them unsuitable for operation atop
untrusted infrastructure. Second, they are designed for use within the
boundaries of a single administrative domain and require the user to
trust the administrators of that domain. Finally, they tend to lack
support for use cases requiring autonomous or remote access to secret
material in a secure manner. These deficiencies give rise to several
additional secret-storage requirements:

\begin{packed_item}
\item Avoidance of the need to place a high degree of trust in any
  single system or administrative domain.
\item Ability to support a range of secret-access use cases, including
  use cases where automatic or remote access to secrets is required.
\end{packed_item}

It is toward these final two requirements that Tutamen attempts to
advance the state of the art over existing secret-storage systems. In
particular, Tutamen supports operational modes where no single entity
other than the client application must be trusted. This allows users
to leverage third party secret-storage providers running Tutamen
servers without having to place high degrees of trust in any single
provider. Tutamen is also designed to scale beyond a single
administrative domain, and does not require centralized control or
administration of each server in a Tutamen deployment. Furthermore,
Tutamen provides support for a modular authentication interface. This
interface makes Tutamen suitable for use in situations where it is
desirable to leverage external environmental information to
automatically evaluate the authenticity of a secret-request or where
it is necessary to keep a human in the authentication loop without
actually requiring that the human be physically present. For example,
Tutamen can be used to store the disk encryption keys required to boot
a headless server, and to only release these keys to the server
requesting them when a human responds to a text message confirming the
boot request.  The remainder of this paper discusses Tutamen's design
and how it can be applied to solve issues such as those raised here.

%%  LocalWords:  Tutamen LastPass HashiCorp's Lyft's Keywhiz OOB SMS
%%  LocalWords:  Tutamen's
