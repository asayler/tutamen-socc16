\section{The Tutamen Platform}
\label{sec:tutamen}

\subsection{Architecture}

The Tutamen Secret Storage platform has three main components:

\begin{packed_desc}
\item[Access Control Servers (ACS):] The systems responsible for
  storing and enforcing secret access control requirements and for
  authenticating clients making requests.
\item[Storage Servers (SS):] The systems responsible for storing
  secrets (or parts of secrets).
\item[Applications:] The systems leveraging the Tutamen platform to
  store and retrieve secrets.
\end{packed_desc}

In general, Tutamen communication occurs between applications and both
types of servers. Tutamen servers do not generally communicates with
each other directly.\footnote{There is one exception to this stamen --
  storage servers need to download the public signing keys from each
  of the access control servers with which they interact.} All
communication in Tutamen takes place via HTTPS connections - and in
some cases leverages mutual TLS to require both client and server
authentication.

Both access control and storage servers are designed to be used
individually or in sets. E.g. An application may store their secret
on a single storage server and delegate access control to a single
access control server, or the application may shard its secret across
multiple storage servers and delegate access control to multiple
access control servers, or any combination thereof. By separating the
access control duties from the secret storage duties, Tutamen offers
the end-user a high degree of flexibility to implement a range of
redundancy and trust requirements.

\subsubsection{Access Control Servers}

The Tutamen Access Control Servers are responsible with authenticating
Tutamen requests as well as storing and enforcing all access control
requirements. Access Control servers expose a number of core data
structures that reflect that manner in which they
operate. Figure~\ref{fig:tutamen:acstructs} shows these structures.

\begin{figure}[th]
  \centering
  \includegraphics[width=\columnwidth]{./figs/pdf/tutamen-datastructures-ac.pdf}
  \caption{Access Control Server Data Structures}
  \label{fig:tutamen:acstructs}
\end{figure}

In order to track and control access from specific users - the access
control server uses per-user accounts. These accounts are generally
designed to map to individual end-users, but they can be used to track
any singular entity to which one wishes to assign specific access
control privileges. Accounts thus form the basis of controlling and
sharing access to secrets via Tutamen. Within each account are one or
more clients. While accounts map to logically singular access control
entities, clients map to specific devices that will need to make
Tutamen requests. Each account has one or more clients. For example,
Jane Coworker would have a single account with three clients: one for
her laptop, one for her desktop, and one for her phone.

Each client is associated with a single TLS key-pair used to
authenticate the client to the access control server. The access
control server serves as the Certificate Authority administering these
certificates. When a new client is created it generates a local RSA
key and uses this key to generate an X509 Certificate Signing
Request~\cite{rfc5280}. This request is then sent to the access
control server where it awaits approval from an existing client in the
account. If approved, the CSR is used to generate a signed certificate
that is sent back to the new client for use in future access control
server communication. To facilitate bootstrapping new accounts, client
CSRs are also generated and sent with each new account request. These
are atomically approved and associated with the new account --
i.e. the initial client is created in tandem with a new account -- all
subsequent clients are then approved by previously approved clients.

While accounts and clients are used to identify specific
users/entities -- the Tutamen access control server also has
authenticators. Authenticators are modular mechanism used to implement
access control requirements beyond granting access on the basis of
accounts. For example, authenticators can support plugins to perform
additional contextual authentication requirements such as only
allowing access during specific times of day or from requests
originating from specific IP addresses. Authenticators can also be
used to implement out-of-band authentication mechanisms such as
confirming approval for a specific request from a user via text
message or otherwise interfacing with external services to gain
approval.

Accounts and authenticators are combined via verifiers. A verifier
consist of a set of accounts and a set of authenticators. In order to
satisfy a verifier a request must originate from a client in ONE of
the listed accounts and must satisfy ALL of the listed authenticators
plugins. A verifier may contain no Authenticators, in which case
authorization is granted solely on the basis of accounts.

The final component of the Tutamen access control specification are
permission groups. Each permission group corresponds to a specific
object (identified via the combination of an object type and an object
ID) within the Tutamen ecosystem. A permission groups contains one or
more permissions - each corresponding to a specific class of actions
that can be preformed on the corresponding object. Each permission
contains a set of verifiers. In order to be granted a given permission
a request must satisfy at least one of the verifiers in this set.

\subsubsection{Storage Servers}

Tutamen storage servers are responsible for storing all or part of
each Tutamen secret. Figure~\ref{fig:tutamen:storagestructs} shows the
core storage server data structures.

\begin{figure}[th]
  \centering
  \includegraphics[width=\columnwidth]{./figs/pdf/tutamen-datastructures-storage.pdf}
  \caption{Storage Server Data Structures}
  \label{fig:tutamen:storagestructs}
\end{figure}

The top-level data structure employed by storage servers is a
collection. A collection represents a logical grouping of one or more
secrets (or parts of secrets). Associated with each collection is a
list of one or more access control servers delegated with enforcing
the access control requirements for the collection. Access control
granularity is thus set at the per-collection, not per-secret level. A
collection is also capable of storing a user-provided metadata to aid
in the mapping of collections to the objects for which they store
secrets.

Each collection stores one or more secrets or secret shards. These
secrets consist of the actual secret data the applications leveraging
Tutamen wishes to store as well as any associated user-provided
metadata. Since access control is set at the per-collection level,
secrets inherit their access control characteristics from the
corresponding collection.

% Move to discussion section ?
How best to map secret data to collections is left up to each
applications. This decision is primarily driven by the fact that
access control is preformed on the per-collection level. Thus, if an
applications requires that a set of secrets always have a common set
of access control requirements (e.g. per-sector encryption keys for a
encrypted block device), it make since to group these secrets into a
single collection. Doing so minimizes the complexity of trying to keep
access control requirements synced across multiple secrets and
increases performance by minimizing the number of requests that the
applications must make of the access control server in order to access
multiple secrets in collection. In other cases where each secret
requires its own access control requirements (e.g. per-file encrypting
keys for a sensitive document), it would be appropriate for the
corresponding application to store only a single secret per
collection.

\subsubsection{Access Control Protocol}

Access control servers control access related to both internal
(i.e. access control server) and external (i.e. storage server)
objects by providing signed authorization tokens in response to valid
requests. Each authorization token grants the bearer with specific
permissions related to a specific object. In this manner, access
control servers provide a form of federated access management than
bears some similarities to previously deployed systems such as
Shibboleth~\cite{leandro2012}. Figure~\ref{fig:tutamen:systembase}
shows the basic communication involved in the Tutamen access control
process.

\begin{figure}[th]
  \centering
  \includegraphics[width=\columnwidth]{./figs/pdf/system-base.pdf}
  \caption{Access Control Communication}
  \label{fig:tutamen:systembase}
\end{figure}

The access control server generates authorization tokens in response
to a client sending an authorization request. Each authorization
request (and each corresponding token) includes two claims binding it
to a specific object: the object type and the object ID. Each request
also contains a claim that binds it to a specific permission
(e.g. read, write, delete, modify) for the corresponding
object. Authorization requests are further bound to the specific
client making the request (authenticated via mutual-TLS) and to an
expiration time -- after which the token is no longer
valid. Listing~\ref{lst:tutamen:token} shows the structure of Tutamen
access control tokens.

\begin{lstlisting}[float,
    language=JavaScript,
    caption={Authorization Token Contents},
    label=lst:tutamen:token]
{
  "claims":
  {
    "objtype": <object type>,
    "objuid": <object ID>,
    "permission": <object permission>,
    "requesting-client": <client ID>,
    "requesting-account": <account ID>,
    "expiration": <expiration date and time>
  }
  "signature": <AC server signature>
}
\end{lstlisting}

Upon receiving a authorization request from a client, the access
control server looks up the permission group for the corresponding
object (identified via the combination of object type and object ID)
and then loads the verifier set corresponding to the requested
permission. The server then traverses each verifier in this set -
verifying both client membership in one of the accounts listed in the
verifier as well as executing any authenticator plugins required by
the verifier until it finds (or fails to find) a verifier that is
satisfied by the request. If the server is able to verify compliance
with at least one verifier in the permission set it grants the
authorization request and returns a signed authorization token that
includes the object type, object ID, granted permission, expiration
time. The bearer of this token can then present it to either the
access control server or a storage server in order to be granted the
right to perform the class of operations included in the corresponding
permission on the corresponding object.

All requests to either storage or access control server related to the
manipulation of server data objects must be accompanied by a valid
token. The receiving server validated this token using the public
signing key of the associated AC server: for request to the AC sever
itself, this key is available internally. For requests to external
storage servers, the signing key is downloaded by the target server
from the access control server and cached for future use. In this
manner, access control servers are responsible both for granting and
verifying authorization requests and signing the corresponding tokens
as well as for verifying tokens accompanying requests to preform
actions on access control server data structures (e.g. to create or
modify verifiers or accounts). Storage servers are responsible only
for verifying tokens accompanying requests to perform actions on
storage server data structures (e.g. to create a collection or read a
secret).

\subsubsection{Distributed Usage}

Tutamen is designed to be used in both centralized and distributed
used cases. The simplest Tutamen arrangement (e.g. as shown in
Figure~\ref{fig:tutamen:systembase}) include leveraging a single
Tutamen access control server and a single storage server. It is
possible or these two servers to be co-located on a single machine -
or for them to be operated separately for performance purposes. In
this arrangement the storage server store a complete copy of each
secret while the access control server is solely charged with
enforcing access to these secrets. While this use case is easy to
deploy it has two notable downsides. First, it forces the user to
place a high degree of trust in the operator of the access control
server (who has complete control over whether or not the access
control rules for a given secret are being faithfully enforced) as
well as the operator of the storage server (who, likewise, must
faithfully verify incoming tokens and avoid otherwise leaking secret
data). Second, it lacks any form of redundancy - if either the access
control server or the storage server is unavailable the application
will be unable to retrieve any secrets.

To overcome these deficiencies, we've designed Tutamen to be leveraged
in a distributed manner in addition to supporting simpler modes of
centralized operation. Operating Tutamen in a distributed manner is
largely a task that is pushed down to the application and client
levels -- With the exception of supporting the necessary primitives to
support such operation, both Tutamen storage and access control server
are designed to by largely agnostic to whether they are being used in
a centralized or a distributed manner. This design has the benefit of
avoiding server-side scaling challenges, allowing the extra overhead
required for distributed operation to be supported by each application
that requires it.

\begin{figure}[th]
  \centering
  \includegraphics[width=\columnwidth]{./figs/pdf/system-distributed.pdf}
  \caption{Distributed Operation}
  \label{fig:tutamen:systemdistributed}
\end{figure}

Figure~\ref{fig:tutamen:systemdistributed} shows the basic layout of a
distributed Tutamen setup. In such a setup, the Tutamen application
first shards its secret using a $(k, n)$ threshold schemes such as
Shamir's~\cite{shamir1979}. The application chooses the value of $n$
based on the number of storage servers they wish to utilize. The value
of $k$ is then chosen to control how many of the server must be
responsive in order to retrieve the secret -- i.e. the difference
between $n$ and $k$ controls how much storage redundancy the system
has by setting the number of storage server that can be unavailable
before access to the secret itself is lost. The application then
pushes each shard to the $n$ storage servers. If the application is
merely concerned about storage redundancy or about their ability to
trust storage server operates, it can simply delegate the access
control for each secret shard to a single access control server. To
retrieve such a secret the application would request the necessary
token from the access control server and include it in the request to
each storage server for their shard of the secret. When the
application receives a response from $k$ of the storage servers, it is
able to reconstruct the original secret.

In most cases, however, we imagine that in addition to wishing to
mitigate storage server trust and reliability issues, the application
will also wish to protect itself against access control server trust
and reliability failures. To accomplish this latter, the application
can leverage Tutamen storage server design allowing the specification
of two pieces of access control metadata that accompany each secret
collection: a list of AC servers and a minimum number of server from
which valid tokens must be received to allow the associated
requests. Using these parameters forms the basis of an additional $(k,
n)$ threshold scheme for access control servers -- e.g. the
application may associated a list of $n$ access control servers with
each secret from which an application must acquire at least $k$ valid
tokens in order to gain access. Thus, if the the user does not wish to
trust a single access control server, they may require tokens from at
least $k$ different AC servers in order to access the secrets in a
given collection. Likewise, if the application wishes to withstand the
failure of one or more AC servers, it can specify $n$ possible AC
servers where $n > k$.

In order to facilitate ease of management when operating is a
distributed mode, Tutamen also support allowing applications to
request specific IDs for each object when creating them. This allows
clients to use the same ID across multiple serves alleviating the
burden of maintaining a mapping between unique object IDs and the
servers to which they correspond. Using the same object IDs across
multiple servers also allows for more efficient token management --
e.g if an application uses the same collection ID on there separate
storage serves, all of which delegate a common set of access control
servers, it's possible for the application to use a single token
granting access to the relevant collection ID on all three
servers. Without this capability, an application would be forced to
request multiple tokens from each access control server corresponding
to the collection ID used on each storage server.

The ability to request specific object IDs does have one downside --
it opens Tutamen up to a possible denial-of-service (DoS) attack where
an attacker attempts to request the object IDs they know another
application wishes to use for themselves. Since each server may only
use each object ID once, the first application to request a given ID
gets it. Thus, if an adversary knew which object IDs a given
application planned to use (or was already using on a subset of
possible servers), they could request these object IDs on any server
on which they were not yet in use for themselves, depriving the
original application for using those servers without first undertaking
the burden of changing object IDs. None the less, we believe the
convenience afforded by allowing applications to request specific
object IDs outweigh the potential for abuse.

% Storage Server Cert Verification Option

%\subsubsection{Bootstrapping Trust}

%\subsubsection{Applications}

% Mapping

\subsubsection{Example}

To illustrate the interaction of the various components of the Tutamen
platform, we present a basic example of the steps taken by an
application to store and then retrieve a secret via Tutamen. In this
example, we're assume the applications is using three storage servers
and two access control servers as shown in
Figure~\ref{fig:tutamen:systemdistributed}. We also assume the
application has already bootstrapped an account and client -- e.g. it
previously contacted the AC server with a request to create a new
account and associated client, presenting a CSR corresponding to a
locally stored private key and receiving a signed client certificate
in response. For the purposes of this example, we'll also assume that
the creator of the secret in question wishes to protect access to the
secret by requiring SMS text message approval. We'll further assume
that the creator also wishes to share the secret with a trusted
colleague in addition to accessing it themselves.

In order to store a new secret, the application performs the following
steps:\footnote{Skipped from this description is the process of
  creating authenticators (optional), verifiers, and permissions
  groups for each of the AC data structures in question (i.e. the
  collection authenticator, collection verifier, and collection
  permissions group). These permissions groups are necessary to
  control who can read, modify, or delete the corresponding AC objects
  after creation. The process for creating said structures is similar
  to the process described for creating the collection-related
  authenticator, verifier, and permissions group -- and is thus left
  out of the description to avoid confusion and save space.}

\begin{packed_enum}
\item In order to require SMS-based approvals for secret access, the
  application starts by creating a new authenticator using the SMS
  plugin and specifying the phone number of the secret's creator. To
  achieve this, the application selects a random ID for the new
  authenticator, requests the necessary tokens to create the
  authenticator from each of the two AC servers, and finally uses
  these tokens to create the authenticator on both AC servers using
  the selected ID.
\item The application then creates a verifier to control access to the
  secret (or, more correctly, to the collection in which the secret
  will be stored). The application specifies two account IDs for the
  new verifier: the account ID of the creator (i.e. the account ID the
  application is currently using) and the account ID of the creator's
  trusted colleague. The application also specifies the ID of the SMS
  authenticator created in the previous step. The application selects
  a random ID for the new verifier, requests the necessary verifier
  creation tokens from each AC server, and then uses these tokens to
  create the verifier on both AC servers using the chosen ID.
\item Next the application must select an ID for the new collection in
  which the secret will be stored. This ID will be used on both the AC
  servers to bind the permission group to the new collection as well
  as on the storage servers where it will be used for the new
  collection itself. The application randomly generates an ID (e.g. a
  UUID~\cite{leach2005}).
\item Next the application must create a permissions group to control
  access to the new collection. This permissions group will use a
  single verifier for all permissions (i.e. the one created in the
  previous step). The application requests the necessary permissions
  group creation tokens from each AC server and uses these tokens to
  crate a new permission group on each server that requires the
  previously created verifier and is bound to the selected collection
  ID.
\item The application must now create the new collection that will be
  used to store the secret. To do this, it requests the necessary
  collection creation tokens from each of the AC servers\footnote{We
    assume the storage servers in question are configured to delegate
    server-level secret creation access control to one or both of the
    AC servers}. The application then uses these tokens and the
  previously select collection ID to create a new collection on each
  of the three storage servers. The application specifies that access
  control for the collection should be delegated to the two AC servers
  and that concurring tokens from both servers should be required to
  perform operations on the collection.
\item At this point the application is ready to store the secret
  itself. It begins by sharding the secret into 3 parts, two of which
  are sufficient to reconstruct the secret.
\item The application then requests the necessary secret creation
  tokens from both AC servers for the chosen collection ID. Since the
  granting of these tokens is governed by the verifier created above,
  the AC servers will confirm they come from an approved account and
  text the creator's phone number for approval. Since this token
  request comes from the creator's account and assuming the creator
  approves access via text message response, the tokens will be
  granted.
\item The application uses these tokens to create a new ``secret''
  within the collection on each of the three storage servers --
  storing one shard of the original secret on each storage server.
\item The storage servers verify the tokens in question using the
  public singing keys from both AC servers. If valid, the storage
  servers create and store the secret shards.
\end{packed_enum}

At this point, the original secret has been sharded into 3 (choose 2)
parts, each of which is stored in a common collection on one of the
three storage servers. In order to access any single shard, an
application must secure a token granting read access to the
corresponding collection ID from each of the two AC servers. To be
granted read access the token request must originate form the
creator's account or the account of their trusted colleague and the
creator must approve the request via SMS.

In order to restore the stored secret, the application performs the
following steps:

\begin{packed_enum}
\item The application begins by requesting the necessary collection
  read tokens for the ID of the collection used to store the secret
  shards from both AC servers. The collection read permission is
  governed by the previously created verifier, and grants access based
  on SMS approval and client membership in the creator's or their
  colleague's account.
\item As before, this token request will trigger an SMS approval
  message to the secret's creator. If they respond in the affirmative,
  and assuming the application has access to the client TLS key-pair
  associated with the secret creator's account, the tokens will be
  issued.
\item The application uses the tokens to request copies of the secret
  shards from each storage server. Since only two of these shards are
  required to reconstruct the secret, the application may opt to ask
  for only two shards, or it may ask for all three and return the
  first tow it receives.
\item The storage servers verify the tokens in question using the
  public singing keys from both AC servers. If valid, the storage
  servers grant access to the requested secrets.
\item The application recombines two of the three shards to recreate
  the original secret.
\end{packed_enum}

\subsection{Implementation}

In order to demonstrate and test the Tutamen platform we've created
reference implementations for the Storage Server, Access Control Server,
and several client libraries and applications.

Our Tutamen server implementation exposes a RESTful
interface~\cite{fielding2000} for both the access control and storage
server APIs. This interface both accepts and responds using
JSON~\cite{json} messages over the HTTPS protocol. The full access
control server API specification as well as the API reference
implementation source code is available online
at~\cite{src-tutamen-apiaccesscontrol}. Likewise, the storage server
API specification and source code can be found
at~\cite{src-tutamen-apistorage}. Both APIs are freely available under
the terms of the AGPLv3. The server APIs are written in Python 3 using
the Flask web framework~\cite{python-flask}. Both servers are designed
to be served via WSGI~\cite{pep3333} using the Apache HTTP
Server~\cite{apache} for TLS termination and client-certificate
verification.

Both Tutamen servers rely on a shared \texttt{pytutamn-server} python
library for the implementation of their core logic. The
\texttt{pytutamen-server} source is available
at~\cite{src-tutamen-pytutamenserver} under the terms of the
LGPLv3. This library leverages the Redis~\cite{redis} key-value store
for persistent storage and the Cryptography~\cite{python-cryptography}
python library for x509 support. Our Tutamen implementation adopts the
JSON Web Signature (JWS)~\cite{rfc7515} and JSON Web Token
(JWT)~\cite{rfc7519} specifications for exchanging cryptographically
authenticated, claim-based tokens between Tutamen applications, access
control servers, and storage servers. We leverage the
pyjwt~\cite{pyjwt} library for JWS and JWT support.

%%  Localwords:  Tutamen ACS HTTPS CSR CSRs Authenticators verifiers
%%  LocalWords:  authenticators authenticator objtype objuid Shamir's
%%  LocalWords:  DoS SMS Redis AGPLv JWS JWT pyjwt
